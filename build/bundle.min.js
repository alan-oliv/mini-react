
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var TEXT_ELEMENT = 'TEXT ELEMENT';
function createElement(type, config) {
  var _ref;

  var props = Object.assign({}, config);

  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var hasChildren = args.length > 0;
  var rawChildren = hasChildren ? (_ref = []).concat.apply(_ref, args) : [];
  props.children = rawChildren.filter(function (c) {
    return c != null && c !== false;
  }).map(function (c) {
    return c instanceof Object ? c : createTextElement(c);
  });
  return {
    type: type,
    props: props
  };
}

function createTextElement(value) {
  return createElement(TEXT_ELEMENT, {
    nodeValue: value
  });
}

var isEvent = function isEvent(name) {
  return name.startsWith('on');
};

var isAttribute = function isAttribute(name) {
  return !isEvent(name) && name != 'children' && name != 'style';
};

var isNew = function isNew(prev, next) {
  return function (key) {
    return prev[key] !== next[key];
  };
};

var isGone = function isGone(prev, next) {
  return function (key) {
    return !(key in next);
  };
};

function updateDomProperties(dom, prevProps, nextProps) {
  // Remove event listeners
  Object.keys(prevProps).filter(isEvent).filter(function (key) {
    return !(key in nextProps) || isNew(prevProps, nextProps)(key);
  }).forEach(function (name) {
    var eventType = name.toLowerCase().substring(2);
    dom.removeEventListener(eventType, prevProps[name]);
  }); // Remove attributes

  Object.keys(prevProps).filter(isAttribute).filter(isGone(prevProps, nextProps)).forEach(function (name) {
    dom[name] = null;
  }); // Set attributes

  Object.keys(nextProps).filter(isAttribute).filter(isNew(prevProps, nextProps)).forEach(function (name) {
    dom[name] = nextProps[name];
  }); // Set style

  prevProps.style = prevProps.style || {};
  nextProps.style = nextProps.style || {};
  Object.keys(nextProps.style).filter(isNew(prevProps.style, nextProps.style)).forEach(function (key) {
    dom.style[key] = nextProps.style[key];
  });
  Object.keys(prevProps.style).filter(isGone(prevProps.style, nextProps.style)).forEach(function (key) {
    dom.style[key] = '';
  }); // Add event listeners

  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(function (name) {
    var eventType = name.toLowerCase().substring(2);
    dom.addEventListener(eventType, nextProps[name]);
  });
}
function createDomElement(fiber) {
  console.log(fiber);
  var isTextElement = fiber.type === TEXT_ELEMENT;
  var dom = isTextElement ? document.createTextNode('') : document.createElement(fiber.type);
  updateDomProperties(dom, [], fiber.props);
  return dom;
}

var HOST_COMPONENT = 'host';
var CLASS_COMPONENT = 'class';
var HOST_ROOT = 'root'; // Effect tags

var PLACEMENT = 1;
var DELETION = 2;
var UPDATE = 3;
var ENOUGH_TIME = 1; // Global state

var updateQueue = [];
var nextUnitOfWork = null;
var pendingCommit = null;

function createInstance(fiber) {
  var instance = new fiber.type(fiber.props);
  instance.__fiber = fiber;
  return instance;
}

function render(elements, containerDom) {
  updateQueue.push({
    from: HOST_ROOT,
    dom: containerDom,
    newProps: {
      children: elements
    }
  });
  requestIdleCallback(performWork);
}
function scheduleUpdate(instance, partialState) {
  updateQueue.push({
    from: CLASS_COMPONENT,
    instance: instance,
    partialState: partialState
  });
  requestIdleCallback(performWork);
}

function performWork(deadline) {
  workLoop(deadline);

  if (nextUnitOfWork || updateQueue.length > 0) {
    requestIdleCallback(performWork);
  }
}

function workLoop(deadline) {
  if (!nextUnitOfWork) {
    resetNextUnitOfWork();
  }

  while (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }

  if (pendingCommit) {
    commitAllWork(pendingCommit);
  }
}

function resetNextUnitOfWork() {
  var update = updateQueue.shift();

  if (!update) {
    return;
  } // Copy the setState parameter from the update payload to the corresponding fiber


  if (update.partialState) {
    update.instance.__fiber.partialState = update.partialState;
  }

  var root = update.from == HOST_ROOT ? update.dom._rootContainerFiber : getRoot(update.instance.__fiber);
  nextUnitOfWork = {
    tag: HOST_ROOT,
    stateNode: update.dom || root.stateNode,
    props: update.newProps || root.props,
    alternate: root
  };
}

function getRoot(fiber) {
  var node = fiber;

  while (node.parent) {
    node = node.parent;
  }

  return node;
}

function performUnitOfWork(wipFiber) {
  beginWork(wipFiber);

  if (wipFiber.child) {
    return wipFiber.child;
  } // No child, we call completeWork until we find a sibling


  var uow = wipFiber;

  while (uow) {
    completeWork(uow);

    if (uow.sibling) {
      // Sibling needs to beginWork
      return uow.sibling;
    }

    uow = uow.parent;
  }
}

function beginWork(wipFiber) {
  if (wipFiber.tag == CLASS_COMPONENT) {
    updateClassComponent(wipFiber);
  } else {
    updateHostComponent(wipFiber);
  }
}

function updateHostComponent(wipFiber) {
  if (!wipFiber.stateNode) {
    wipFiber.stateNode = createDomElement(wipFiber);
  }

  var newChildElements = wipFiber.props.children;
  reconcileChildrenArray(wipFiber, newChildElements);
}

function updateClassComponent(wipFiber) {
  var instance = wipFiber.stateNode;

  if (instance == null) {
    // Call class constructor
    instance = wipFiber.stateNode = createInstance(wipFiber);
  } else if (wipFiber.props == instance.props && !wipFiber.partialState) {
    // No need to render, clone children from last time
    cloneChildFibers(wipFiber);
    return;
  }

  instance.props = wipFiber.props;
  instance.state = Object.assign({}, instance.state, wipFiber.partialState);
  wipFiber.partialState = null;
  var newChildElements = wipFiber.stateNode.render();
  reconcileChildrenArray(wipFiber, newChildElements);
}

function arrify(val) {
  return val == null ? [] : Array.isArray(val) ? val : [val];
}

function reconcileChildrenArray(wipFiber, newChildElements) {
  var elements = arrify(newChildElements);
  var index = 0;
  var oldFiber = wipFiber.alternate ? wipFiber.alternate.child : null;
  var newFiber = null;

  while (index < elements.length || oldFiber != null) {
    var prevFiber = newFiber;
    var element = index < elements.length && elements[index];
    var sameType = oldFiber && element && element.type == oldFiber.type;

    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        tag: oldFiber.tag,
        stateNode: oldFiber.stateNode,
        props: element.props,
        parent: wipFiber,
        alternate: oldFiber,
        partialState: oldFiber.partialState,
        effectTag: UPDATE
      };
    }

    if (element && !sameType) {
      newFiber = {
        type: element.type,
        tag: typeof element.type === 'string' ? HOST_COMPONENT : CLASS_COMPONENT,
        props: element.props,
        parent: wipFiber,
        effectTag: PLACEMENT
      };
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = DELETION;
      wipFiber.effects = wipFiber.effects || [];
      wipFiber.effects.push(oldFiber);
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling;
    }

    if (index == 0) {
      wipFiber.child = newFiber;
    } else if (prevFiber && element) {
      prevFiber.sibling = newFiber;
    }

    index++;
  }
}

function cloneChildFibers(parentFiber) {
  var oldFiber = parentFiber.alternate;

  if (!oldFiber.child) {
    return;
  }

  var oldChild = oldFiber.child;
  var prevChild = null;

  while (oldChild) {
    var newChild = {
      type: oldChild.type,
      tag: oldChild.tag,
      stateNode: oldChild.stateNode,
      props: oldChild.props,
      partialState: oldChild.partialState,
      alternate: oldChild,
      parent: parentFiber
    };

    if (prevChild) {
      prevChild.sibling = newChild;
    } else {
      parentFiber.child = newChild;
    }

    prevChild = newChild;
    oldChild = oldChild.sibling;
  }
}

function completeWork(fiber) {
  if (fiber.tag == CLASS_COMPONENT) {
    fiber.stateNode.__fiber = fiber;
  }

  if (fiber.parent) {
    var childEffects = fiber.effects || [];
    var thisEffect = fiber.effectTag != null ? [fiber] : [];
    var parentEffects = fiber.parent.effects || [];
    fiber.parent.effects = parentEffects.concat(childEffects, thisEffect);
  } else {
    pendingCommit = fiber;
  }
}

function commitAllWork(fiber) {
  fiber.effects.forEach(function (f) {
    commitWork(f);
  });
  fiber.stateNode._rootContainerFiber = fiber;
  nextUnitOfWork = null;
  pendingCommit = null;
}

function commitWork(fiber) {
  if (fiber.tag == HOST_ROOT) {
    return;
  }

  var domParentFiber = fiber.parent;

  while (domParentFiber.tag == CLASS_COMPONENT) {
    domParentFiber = domParentFiber.parent;
  }

  var domParent = domParentFiber.stateNode;

  if (fiber.effectTag == PLACEMENT && fiber.tag == HOST_COMPONENT) {
    domParent.appendChild(fiber.stateNode);
  } else if (fiber.effectTag == UPDATE) {
    updateDomProperties(fiber.stateNode, fiber.alternate.props, fiber.props);
  } else if (fiber.effectTag == DELETION) {
    commitDeletion(fiber, domParent);
  }
}

function commitDeletion(fiber, domParent) {
  var node = fiber;

  while (true) {
    if (node.tag == CLASS_COMPONENT) {
      node = node.child;
      continue;
    }

    domParent.removeChild(node.stateNode);

    while (node != fiber && !node.sibling) {
      node = node.parent;
    }

    if (node == fiber) {
      return;
    }

    node = node.sibling;
  }
}

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    _classCallCheck(this, Component);

    this.props = props || {};
    this.state = this.state || {};
  }

  _createClass(Component, [{
    key: "setState",
    value: function setState(partialState) {
      scheduleUpdate(this, partialState());
    }
  }]);

  return Component;
}();

var Component$1 =
/*#__PURE__*/
function () {
  function Component() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, Component);

    if (props) {
      this.props = props;
      this.state = this.state || {};
    }
  }

  _createClass(Component, [{
    key: "setState",
    value: function setState(newState) {
      var message = {
        from: 'class',
        instance: this,
        state: newState()
      };
      // this.state = Object.assign(this.state, state);
    }
  }]);

  return Component;
}();

/* eslint-disable */
var Node = (function (_ref) {
  var tagName = _ref.tagName,
      _ref$props = _ref.props,
      props = _ref$props === void 0 ? {} : _ref$props,
      componentClass = _ref.componentClass,
      rest = _objectWithoutProperties(_ref, ["tagName", "props", "componentClass"]);

  var type = tagName ? tagName : componentClass;
  Object.assign(props, rest);
  return {
    type: type,
    props: props
  };
});

var LimitLabel =
/*#__PURE__*/
function (_Component) {
  _inherits(LimitLabel, _Component);

  function LimitLabel(props) {
    _classCallCheck(this, LimitLabel);

    return _possibleConstructorReturn(this, _getPrototypeOf(LimitLabel).call(this, props));
  }

  _createClass(LimitLabel, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          maxLimit = _this$props.maxLimit,
          definedLimit = _this$props.definedLimit;
      return Node({
        tagName: 'p',
        textContent: "R$ ".concat(maxLimit - definedLimit, " dispon\xEDveis")
      });
    }
  }]);

  return LimitLabel;
}(Component$1);

var App =
/*#__PURE__*/
function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    var _this;

    _classCallCheck(this, App);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, props));
    _this.state = {
      definedLimit: 2500,
      maxLimit: 5000
    };
    return _this;
  }

  _createClass(App, [{
    key: "setDefinedLimit",
    value: function setDefinedLimit(e) {
      this.setState(function () {
        return {
          definedLimit: parseInt(e.target.value)
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$state = this.state,
          maxLimit = _this$state.maxLimit,
          definedLimit = _this$state.definedLimit;
      return createElement('div', {}, [createElement('h1', {}, 'Ajuste de limite'), createElement('input', {
        tagName: 'input',
        type: 'text',
        value: definedLimit,
        onkeypress: function onkeypress(e) {
          return _this2.setDefinedLimit(e);
        }
      }, []), createElement(LimitLabel, {
        maxLimit: maxLimit,
        definedLimit: definedLimit
      }, []), createElement('input', {
        type: 'range',
        min: 0,
        max: maxLimit,
        value: definedLimit,
        oninput: function oninput(e) {
          return _this2.setDefinedLimit(e);
        }
      }, [])]); // return Node({
      //   tagName: 'div',
      //   children: [
      //     Node({
      //       tagName: 'h1',
      //       textContent: 'Ajuste de limite'
      //     }),
      //     Node({
      //       tagName: 'input',
      //       type: 'text',
      //       value: definedLimit,
      //       onkeypress: e => this.setDefinedLimit(e)
      //     }),
      //     Node({
      //       componentClass: LimitLabel,
      //       props: {
      //         maxLimit,
      //         definedLimit
      //       }
      //     }),
      //     Node({
      //       tagName: 'input',
      //       type: 'range',
      //       min: 0,
      //       max: maxLimit,
      //       value: definedLimit,
      //       oninput: e => this.setDefinedLimit(e)
      //     })
      //   ]
      // });
    }
  }]);

  return App;
}(Component);

var element = createElement(App, {});
render(element, document.getElementById('root'));
