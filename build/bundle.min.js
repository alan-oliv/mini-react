
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var CLASS = 'class';
var ROOT_WRAPPER = 'root';

var HOST_WRAPPER = 'host';
var INSERT = 1;
var DELETE = 2;
var UPDATE = 3;
var THREAD_TIME = 1;

var instantiate = function instantiate(fiber) {
  var instance = new fiber.type(fiber.props);
  instance.__fiber = fiber;
  return instance;
};

var findRoot = function findRoot(fiber) {
  var node = fiber;

  while (node.parent) {
    node = node.parent;
  }

  return node;
};

var _renderer = null;
var _queue = [];
var _nextMessage = null;
var _pending = null;

var setRenderer = function setRenderer(renderer) {
  return _renderer = renderer;
};

var addMessage = function addMessage(message) {
  _queue.push(message);

  requestIdleCallback(initConsumer);
};

var initConsumer = function initConsumer(time) {
  consumeQueue(time);

  if (_nextMessage || _queue.length > 0) {
    requestIdleCallback(initConsumer);
  }
};

var consumeQueue = function consumeQueue(time) {
  !_nextMessage && setNextMessage();

  while (_nextMessage && time.timeRemaining() > THREAD_TIME) {
    _nextMessage = consumeMessage(_nextMessage);
  }

  if (_pending) {
    pushAll(_pending);
  }
};

var setNextMessage = function setNextMessage() {
  var changes = _queue.shift();

  if (!changes) {
    return;
  }

  var instance = changes.instance,
      partialState = changes.partialState,
      dom = changes.dom,
      newProps = changes.newProps,
      from = changes.from;

  if (partialState) {
    instance.__fiber.partialState = partialState;
  }

  var root = from == ROOT_WRAPPER ? dom._rootContainerFiber : findRoot(instance.__fiber);
  _nextMessage = {
    tag: ROOT_WRAPPER,
    stateNode: dom || root.stateNode,
    props: newProps || root.props,
    alternate: root
  };
};

var consumeMessage = function consumeMessage(wipTree) {
  if (wipTree.tag == CLASS) {
    var instance = wipTree.stateNode;

    if (instance == null) {
      instance = wipTree.stateNode = instantiate(wipTree);
    } else if (wipTree.props == instance.props && !wipTree.partialState) {
      childrenClone(wipTree);
      return;
    }

    instance.props = wipTree.props;
    instance.state = Object.assign({}, instance.state, wipTree.partialState);
    wipTree.partialState = null;
    var newChildElements = wipTree.stateNode.render();
    childrenReconcile(wipTree, newChildElements);
  } else {
    if (!wipTree.stateNode) {
      wipTree.stateNode = _renderer.createElement(wipTree);
    }

    var _newChildElements = wipTree.props.children;
    childrenReconcile(wipTree, _newChildElements);
  }

  if (wipTree.child) {
    return wipTree.child;
  }

  var uow = wipTree;

  while (uow) {
    threadDone(uow);

    if (uow.sibling) {
      return uow.sibling;
    }

    uow = uow.parent;
  }
};

var childrenReconcile = function childrenReconcile(wipTree, newChildElements) {
  var elements = [].concat(newChildElements);
  var index = 0;
  var oldFiber = wipTree.alternate ? wipTree.alternate.child : null;
  var newFiber = null;

  while (index < elements.length || oldFiber != null) {
    var prevFiber = newFiber;
    var element = index < elements.length && elements[index];
    var sameType = oldFiber && element && element.type == oldFiber.type;

    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        tag: oldFiber.tag,
        stateNode: oldFiber.stateNode,
        props: element.props,
        parent: wipTree,
        alternate: oldFiber,
        partialState: oldFiber.partialState,
        effectTag: UPDATE
      };
    }

    if (element && !sameType) {
      newFiber = {
        type: element.type,
        tag: typeof element.type === 'string' ? HOST_WRAPPER : CLASS,
        props: element.props,
        parent: wipTree,
        effectTag: INSERT
      };
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = DELETE;
      wipTree.effects = wipTree.effects || [];
      wipTree.effects.push(oldFiber);
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling;
    }

    if (index == 0) {
      wipTree.child = newFiber;
    } else if (prevFiber && element) {
      prevFiber.sibling = newFiber;
    }

    index++;
  }
};

var childrenClone = function childrenClone(parentFiber) {
  var oldFiber = parentFiber.alternate;

  if (!oldFiber.child) {
    return;
  }

  var oldChild = oldFiber.child;
  var prevChild = null;

  while (oldChild) {
    var newChild = {
      type: oldChild.type,
      tag: oldChild.tag,
      stateNode: oldChild.stateNode,
      props: oldChild.props,
      partialState: oldChild.partialState,
      alternate: oldChild,
      parent: parentFiber
    };

    if (prevChild) {
      prevChild.sibling = newChild;
    } else {
      parentFiber.child = newChild;
    }

    prevChild = newChild;
    oldChild = oldChild.sibling;
  }
};

var threadDone = function threadDone(fiber) {
  if (fiber.tag == CLASS) {
    fiber.stateNode.__fiber = fiber;
  }

  if (fiber.parent) {
    var childEffects = fiber.effects || [];
    var thisEffect = fiber.effectTag != null ? [fiber] : [];
    var parentEffects = fiber.parent.effects || [];
    fiber.parent.effects = parentEffects.concat(childEffects, thisEffect);
  } else {
    _pending = fiber;
  }
};

var pushAll = function pushAll(fiber) {
  fiber.effects.forEach(function (f) {
    pushOne(f);
  });
  fiber.stateNode._rootContainerFiber = fiber;
  _nextMessage = null;
  _pending = null;
};

var pushOne = function pushOne(fiber) {
  if (fiber.tag == ROOT_WRAPPER) {
    return;
  }

  var domParentFiber = fiber.parent;

  while (domParentFiber.tag == CLASS) {
    domParentFiber = domParentFiber.parent;
  }

  var domParent = domParentFiber.stateNode;

  if (fiber.effectTag == INSERT && fiber.tag == HOST_WRAPPER) {
    domParent.appendChild(fiber.stateNode);
  } else if (fiber.effectTag == UPDATE) {
    _renderer.propsUpdate(fiber.stateNode, fiber.alternate.props, fiber.props);
  } else if (fiber.effectTag == DELETE) {
    removeFiber(fiber, domParent);
  }
};

var removeFiber = function removeFiber(fiber, domParent) {
  var node = fiber;

  while (true) {
    if (node.tag == CLASS) {
      node = node.child;
      continue;
    }

    domParent.removeChild(node.stateNode);

    while (node != fiber && !node.sibling) {
      node = node.parent;
    }

    if (node == fiber) {
      return;
    }

    node = node.sibling;
  }
};

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    _classCallCheck(this, Component);

    this.props = props ? props : {};
    this.state = this.state ? this.state : {};
  }

  _createClass(Component, [{
    key: "setState",
    value: function setState(state) {
      var newState = typeof state === 'function' ? state() : state;
      var message = {
        from: CLASS,
        instance: this,
        partialState: newState
      };
      addMessage(message);
    }
  }]);

  return Component;
}();

/* eslint-disable */
var Node = (function (_ref) {
  var tagName = _ref.tagName,
      _ref$props = _ref.props,
      props = _ref$props === void 0 ? {} : _ref$props,
      componentClass = _ref.componentClass,
      rest = _objectWithoutProperties(_ref, ["tagName", "props", "componentClass"]);

  var type = tagName ? tagName : componentClass;
  Object.assign(props, rest);
  return {
    type: type,
    props: props
  };
});

var MiniReact = {
  Component: Component,
  Node: Node
};

var inserted = function inserted(prev, next) {
  return function (key) {
    return prev[key] !== next[key];
  };
};

var deleted = function deleted(prev, next) {
  return function (key) {
    return !(key in next);
  };
};

var event = function event(name) {
  return name.startsWith('on');
};

var attribute = function attribute(name) {
  return !event(name) && name != 'children' && name != 'style';
};

var TEXT_ELEMENT = 'TEXT ELEMENT';

var MiniReactDOM = {
  render: function render(element, container) {
    setRenderer(MiniReactDOM);
    var message = {
      from: ROOT_WRAPPER,
      dom: container,
      newProps: {
        children: element
      }
    };
    addMessage(message);
  },
  createElement: function createElement(el) {
    var text = el.type === TEXT_ELEMENT;
    var dom = text ? document.createTextNode('') : document.createElement(el.type);
    MiniReactDOM.propsUpdate(dom, [], el.props);
    return dom;
  },
  propsUpdate: function propsUpdate(dom, previous, next) {
    previous && Object.keys(previous).filter(attribute).filter(deleted(previous, next)).forEach(function (name) {
      dom[name] = null;
    });
    previous && Object.keys(previous).filter(event).filter(function (key) {
      return !(key in next) || inserted(previous, next)(key);
    }).forEach(function (name) {
      var eventType = name.toLowerCase().substring(2);
      !dom.props && dom.removeEventListener(eventType, previous[name]);
    });
    next && Object.keys(next).filter(attribute).filter(inserted(previous, next)).forEach(function (name) {
      dom[name] = next[name];
    });
    previous && (previous.style = previous.style || {});
    next && (next.style = next.style || {});
    next && Object.keys(next.style).filter(inserted(previous.style, next.style)).forEach(function (key) {
      dom.style[key] = next.style[key];
    });
    previous && next && Object.keys(previous.style).filter(deleted(previous.style, next.style)).forEach(function (key) {
      dom.style[key] = '';
    });
    previous && next && Object.keys(next).filter(event).filter(inserted(previous, next)).forEach(function (name) {
      var eventType = name.toLowerCase().substring(2);
      !dom.props && dom.addEventListener(eventType, next[name]);
    });
  }
};

var LimitInput =
/*#__PURE__*/
function (_Component) {
  _inherits(LimitInput, _Component);

  function LimitInput(props) {
    _classCallCheck(this, LimitInput);

    return _possibleConstructorReturn(this, _getPrototypeOf(LimitInput).call(this, props));
  }

  _createClass(LimitInput, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          definedLimit = _this$props.definedLimit,
          onkeyup = _this$props.onkeyup;
      var width = definedLimit.toString().length * 28;
      var component = Node({
        tagName: 'div',
        className: 'input-wrapper',
        children: [Node({
          tagName: 'span',
          textContent: 'R$'
        }), Node({
          tagName: 'input',
          type: 'number',
          value: definedLimit,
          className: 'text',
          style: {
            width: "".concat(width, "px")
          },
          onkeyup: onkeyup
        }), Node({
          tagName: 'span',
          textContent: ',00'
        })]
      });
      return component;
    }
  }]);

  return LimitInput;
}(Component);

var LimitLabel =
/*#__PURE__*/
function (_Component) {
  _inherits(LimitLabel, _Component);

  function LimitLabel(props) {
    _classCallCheck(this, LimitLabel);

    return _possibleConstructorReturn(this, _getPrototypeOf(LimitLabel).call(this, props));
  }

  _createClass(LimitLabel, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          maxLimit = _this$props.maxLimit,
          definedLimit = _this$props.definedLimit;
      return Node({
        tagName: 'p',
        className: 'limit-label',
        children: [Node({
          tagName: 'span',
          textContent: 'R$'
        }), Node({
          tagName: 'strong',
          textContent: " ".concat(maxLimit - definedLimit)
        }), Node({
          tagName: 'span',
          textContent: ',00 disponíveis'
        })]
      });
    }
  }]);

  return LimitLabel;
}(Component);

var LimitRange =
/*#__PURE__*/
function (_Component) {
  _inherits(LimitRange, _Component);

  function LimitRange(props) {
    _classCallCheck(this, LimitRange);

    return _possibleConstructorReturn(this, _getPrototypeOf(LimitRange).call(this, props));
  }

  _createClass(LimitRange, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          maxLimit = _this$props.maxLimit,
          definedLimit = _this$props.definedLimit,
          oninput = _this$props.oninput;
      var percentage = definedLimit * 100 / maxLimit;
      return Node({
        tagName: 'div',
        className: 'range',
        children: [Node({
          tagName: 'div',
          className: 'fill',
          style: {
            width: "".concat(percentage < 25 ? "calc(".concat(percentage, "% + 30px)") : "".concat(percentage, "%"))
          }
        }), Node({
          tagName: 'input',
          type: 'range',
          min: 0,
          max: maxLimit,
          value: definedLimit,
          step: '100',
          oninput: oninput
        }), Node({
          tagName: 'div',
          className: 'limit',
          children: [Node({
            tagName: 'span',
            textContent: '0'
          }), Node({
            tagName: 'span',
            textContent: "".concat(maxLimit)
          })]
        })]
      });
    }
  }]);

  return LimitRange;
}(Component);

var App =
/*#__PURE__*/
function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    var _this;

    _classCallCheck(this, App);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, props));
    _this.state = {
      definedLimit: 2500,
      maxLimit: 5000
    };
    return _this;
  }

  _createClass(App, [{
    key: "setDefinedLimit",
    value: function setDefinedLimit(e) {
      this.setState(function () {
        return {
          definedLimit: parseInt(e.target.value)
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$state = this.state,
          maxLimit = _this$state.maxLimit,
          definedLimit = _this$state.definedLimit;
      return Node({
        tagName: 'div',
        className: 'app',
        children: [Node({
          tagName: 'h1',
          textContent: 'Ajuste de limite',
          className: 'title'
        }), Node({
          componentClass: LimitInput,
          props: {
            definedLimit: definedLimit,
            onkeyup: function onkeyup(e) {
              return _this2.setDefinedLimit(e);
            }
          }
        }), Node({
          componentClass: LimitLabel,
          props: {
            maxLimit: maxLimit,
            definedLimit: definedLimit
          }
        }), Node({
          componentClass: LimitRange,
          props: {
            maxLimit: maxLimit,
            definedLimit: definedLimit,
            oninput: function oninput(e) {
              return _this2.setDefinedLimit(e);
            }
          }
        })]
      });
    }
  }]);

  return App;
}(Component);

var Nu = MiniReact.Node({
  componentClass: App
});
MiniReactDOM.render(Nu, document.getElementById('root'));
